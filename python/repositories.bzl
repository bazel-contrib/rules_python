# Copyright 2022 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This file contains macros to be called during WORKSPACE evaluation.

For historic reasons, pip_repositories() is defined in //python:pip.bzl.
"""

load("//python/private:toolchains_repo.bzl", "PLATFORMS", "host_platform", "toolchains_repo")
load(
    "//python/private:versions.bzl",
    "MINOR_MAPPING",
    "TOOL_VERSIONS",
    "get_release_url",
)

def py_repositories():
    # buildifier: disable=print
    print("py_repositories is a no-op and is deprecated. You can remove this from your WORKSPACE file")

########
# Remaining content of the file is only used to support toolchains.
########

def _python_repository_impl(rctx):
    platform = rctx.attr.platform
    python_version = rctx.attr.python_version
    (_, url) = get_release_url(platform, python_version)
    download_result = rctx.download_and_extract(
        url = url,
        sha256 = rctx.attr.sha256,
        stripPrefix = "python",
    )

    # Make the Python installation read-only.
    if "windows" not in rctx.os.name:
        exec_result = rctx.execute(["chmod", "-R", "ugo-w", "lib"])
        if exec_result.return_code:
            fail(exec_result.stderr)

    python_bin = "python.exe" if ("windows" in rctx.attr.platform) else "bin/python3"

    build_content = """\
# Generated by python/repositories.bzl

load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

package(default_visibility = ["//visibility:public"])

filegroup(
    name = "files",
    srcs = glob(
        include = [
            "bin/**",
            "DLLs/**",
            "extensions/**",
            "include/**",
            "lib/**",
            "libs/**",
            "Scripts/**",
            "share/**",
        ],
        exclude = [
            "**/* *", # Bazel does not support spaces in file names.
        ],
    ),
)

exports_files(["{python_path}"])

py_runtime(
    name = "py2_runtime",
    interpreter_path = "/bin/false",
    python_version = "PY2",
)

py_runtime(
    name = "py3_runtime",
    files = [":files"],
    interpreter = "{python_path}",
    python_version = "PY3",
)

py_runtime_pair(
    name = "python_runtimes",
    py2_runtime = ":py2_runtime",
    py3_runtime = ":py3_runtime",
)
""".format(
        python_path = python_bin,
    )
    rctx.file("BUILD.bazel", build_content)

    return {
        "name": rctx.attr.name,
        "platform": platform,
        "python_version": python_version,
        "sha256": download_result.sha256,
    }

python_repository = repository_rule(
    _python_repository_impl,
    doc = "Fetches the external tools needed for the Python toolchain.",
    attrs = {
        "platform": attr.string(
            doc = "The platform name for the Python interpreter tarball.",
            mandatory = True,
            values = PLATFORMS.keys(),
        ),
        "python_version": attr.string(
            doc = "The Python version.",
            mandatory = True,
            values = TOOL_VERSIONS.keys() + MINOR_MAPPING.keys(),
        ),
        "sha256": attr.string(
            doc = "The SHA256 integrity hash for the Python interpreter tarball.",
            mandatory = True,
        ),
    },
)

def _host_os_alias_impl(repository_ctx):
    # Base BUILD file for this repository.
    repository_ctx.file("BUILD.bazel", """\
# Generated by python/repositories.bzl
package(default_visibility = ["//visibility:public"])
alias(name = "files",           actual = "@{py_repository}_{host_platform}//:files")
alias(name = "py3_runtime",     actual = "@{py_repository}_{host_platform}//:py3_runtime")
alias(name = "python_runtimes", actual = "@{py_repository}_{host_platform}//:python_runtimes")
alias(name = "python3",         actual = "@{py_repository}_{host_platform}//:bin/python3")
""".format(
        py_repository = repository_ctx.attr.user_repository_name,
        host_platform = host_platform(repository_ctx),
    ))

    # Expose a Starlark file so rules can know what host platform we used and where to find an interpreter
    # when using repository_ctx.path, which doesn't understand aliases.
    repository_ctx.file("defs.bzl", content = """\
# Generated by python/repositories.bzl
host_platform="{host_platform}"
interpreter="@{py_repository}_{host_platform}//:bin/python3"
""".format(
        py_repository = repository_ctx.attr.user_repository_name,
        host_platform = host_platform(repository_ctx),
    ))

_host_os_alias = repository_rule(
    _host_os_alias_impl,
    doc = """Creates a repository with a shorter name meant for the host platform, which contains
    a BUILD.bazel file declaring aliases to the host platform's targets.
    """,
    attrs = {
        "user_repository_name": attr.string(
            mandatory = True,
            doc = "The base name for all created repositories, like 'python38'.",
        ),
    },
)

# Wrapper macro around everything above, this is the primary API.
def python_register_toolchains(name, python_version, **kwargs):
    """Convenience macro for users which does typical setup.

    - Create a repository for each built-in platform like "python_linux_amd64" -
      this repository is lazily fetched when Python is needed for that platform.
    - Create a repository exposing toolchains for each platform like
      "python_platforms".
    - Register a toolchain pointing at each platform.
    Users can avoid this macro and do these steps themselves, if they want more
    control.
    Args:
        name: base name for all created repos, like "python38".
        python_version: the Python version.
        **kwargs: passed to each python_repositories call.
    """
    if python_version in MINOR_MAPPING:
        python_version = MINOR_MAPPING[python_version]

    for platform in PLATFORMS.keys():
        sha256 = TOOL_VERSIONS[python_version]["sha256"].get(platform, None)
        if not sha256:
            continue

        python_repository(
            name = "{name}_{platform}".format(
                name = name,
                platform = platform,
            ),
            sha256 = sha256,
            platform = platform,
            python_version = python_version,
            **kwargs
        )
        native.register_toolchains("@{name}_toolchains//:{platform}_toolchain".format(
            name = name,
            platform = platform,
        ))

    _host_os_alias(
        name = "{name}_host".format(name = name),
        user_repository_name = name,
    )
    toolchains_repo(
        name = "{name}_toolchains".format(name = name),
        user_repository_name = name,
    )
