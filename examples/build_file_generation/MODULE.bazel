# This file replaces the WORKSPACE file when using bzlmod.

# Declares certain properties of the Bazel module represented by the current Bazel repo.
# These properties are either essential metadata of the module (such as the name and version),
# or affect behavior of the current module and its dependents.
module(
    name = "build_file_generation",
    version = "0.0.0",
    compatibility_level = 1,
)

# The following stanza defines the dependency rules_python.
# For typical setups you set the version.
bazel_dep(name = "rules_python", version = "0.0.0")

# The following starlark loads rules_python from the file system.
# For usual setups you should remove this local_path_override block.
local_path_override(
    module_name = "rules_python",
    path = "../..",
)

# The following stanza defines the dependency rules_python.
# For typical setups you set the version.
bazel_dep(name = "rules_python_gazelle_plugin", version = "0.0.0")

# The following starlark loads the gazelle plugingfrom the file system.
# For usual setups you should remove this local_path_override block.
local_path_override(
    module_name = "rules_python_gazelle_plugin",
    path = "../../gazelle",
)

# The following stanza defines the dependency rules_python.
bazel_dep(name = "gazelle", version = "0.29.0", repo_name = "bazel_gazelle")

# The following stanze Returns a proxy object representing a module extension;
# its methods can be invoked to create module extension tags.
python = use_extension("@rules_python//python:extensions.bzl", "python")

# Using the module extension we register a hermetic Python interpreter rather than relying on
# a system-installed interpreter.
# This toolchain will allow bazel to download a specific  python version, and use that version
# for compilation.
python.toolchain(
    name = "python3_9",
    python_version = "3.9",
)

# Import the python toolchain generated by the given module extension into the scope of the current module.
use_repo(python, "python3_9_toolchains")

# Register an already-defined toolchain so that Bazel can use it during toolchain resolution.
register_toolchains(
    "@python3_9_toolchains//:all",
)

# Use the pip extension
pip = use_extension("@rules_python//python:extensions.bzl", "pip")

# Use the extension to call the `pip_repository` rule that invokes `pip`, with `incremental` set.
# Accepts a locked/compiled requirements file and installs the dependencies listed within.
# Those dependencies become available in a generated `requirements.bzl` file.
# You can instead check this `requirements.bzl` file into your repo.
# Because this project has different requirements for windows vs other
# operating systems, we have requirements for each.
pip.parse(
    name = "pip",
    # Generate user friendly alias labels for each dependency that we have.
    incompatible_generate_aliases = True,
    requirements_lock = "//:requirements_lock.txt",
    requirements_windows = "//:requirements_windows.txt",
)

# Imports the pip toolchain generated by the given module extension into the scope of the current module.
use_repo(pip, "pip")
